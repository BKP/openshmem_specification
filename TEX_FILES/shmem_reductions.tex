\bAPI{SHMEM\_REDUCTIONS}{Performs a logical operations across a set of \ac{PE}s.}

\synC %Synopisis for C API


void shmem_int_and_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_and_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longlong_and_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_and_to_all(short *target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);


void shmem_double_max_to_all(double *target, double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double *pWrk, long *pSync);
void shmem_float_max_to_all(float *target, float *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float *pWrk, long *pSync);
void shmem_int_max_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_max_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longdouble_max_to_all(long double *target, long double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_max_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_max_to_all(short *target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);


void shmem_double_min_to_all(double *target, double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double *pWrk, long *pSync);
void shmem_float_min_to_all(float *target, float *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float *pWrk, long *pSync);
void shmem_int_min_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_min_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longdouble_min_to_all(long double *target, long double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_min_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_min_to_all(short *target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);


void shmem_complexd_sum_to_all(double complex *target, double complex *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double complex *pWrk, long *pSync);
void shmem_complexf_sum_to_all(float complex *target, float complex *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float complex *pWrk, long *pSync);
void shmem_double_sum_to_all(double *target, double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double *pWrk, long *pSync);
void shmem_float_sum_to_all(float *target, float *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float *pWrk, long *pSync);
void shmem_int_sum_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_sum_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride,int PE_size, long *pWrk, long *pSync);
void shmem_longdouble_sum_to_all(long double *target, long double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_sum_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_sum_to_all(short *target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);


void shmem_complexd_prod_to_all(double complex *target, double complex *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double complex *pWrk, long *pSync);
void shmem_complexf_prod_to_all(float complex *target, float complex *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float complex *pWrk, long *pSync);
void shmem_double_prod_to_all(double *target, double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, double *pWrk, long *pSync);
void shmem_float_prod_to_all(float *target, float *source, int nreduce, int PE_start, int logPE_stride, int PE_size, float *pWrk, long *pSync);
void	shmem_int_prod_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void shmem_long_prod_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longdouble_prod_to_all(long double *target, long double *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_prod_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride,	 int PE_size, long long *pWrk, long *pSync);
void shmem_short_prod_to_all(short	*target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);


void shmem_int_or_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void	shmem_long_or_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void	shmem_longlong_or_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void	 shmem_short_or_to_all(short *target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);


void shmem_int_xor_to_all(int *target, int *source, int nreduce, int PE_start, int logPE_stride, int PE_size, int *pWrk, long *pSync);
void	shmem_long_xor_to_all(long *target, long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long *pWrk, long *pSync);
void shmem_longlong_xor_to_all(long long *target, long long *source, int nreduce, int PE_start, int logPE_stride, int PE_size, long long *pWrk, long *pSync);
void shmem_short_xor_to_all(short	*target, short *source, int nreduce, int PE_start, int logPE_stride, int PE_size, short *pWrk, long *pSync);
%*\synCE %DO NOT DELETE. THIS LINE IS NOT A COMMENT

\synF %Synopsis for FORTRAN API


CALL SHMEM_INT4_AND_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_AND_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)

CALL SHMEM_INT4_MAX_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_MAX_TO_ALL(target, source,	 nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_MAX_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_MAX_TO_ALL(target,	source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_MAX_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)


CALL SHMEM_INT4_MIN_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_MIN_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_MIN_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_MIN_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_MIN_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)


CALL SHMEM_COMP4_SUM_TO_ALL(target,	 source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_COMP8_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_SUM_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)


CALL SHMEM_COMP4_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_COMP8_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_PROD_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)


CALL SHMEM_INT4_OR_TO_ALL(target,	 source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_OR_TO_ALL(target,	source,	 nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)	


CALL SHMEM_COMP4_XOR_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT4_XOR_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_XOR_TO_ALL(target, source, nreduce, PE_start, logPE_stride, PE_size, pWrk, pSync)
 %*\synFE   %DO NOT DELETE. THIS LINE IS NOT A COMMENT  

% Arguments table. If no arguments you can use \argRow{None}{}{} 
\desB{   
       \argRow{IN}{target}{A symmetric array, of length \VAR{nreduce} elements, to receive the result of the reduction operations. The data type of target varies with the version of the reduction routine being called. When calling from \CorCpp,	refer to the SYNOPSIS section for data type information. }
	\argRow{IN}{source}{ A symmetric array, of length \VAR{nreduce} elements, that contains one element for each separate reduction operation.	The source argument must have the same data type as target.}
        \argRow{IN}{\VAR{nreduce}}{The number of elements in the target and source arrays. \VAR{nreduce} must be of type integer. If you are using \Fortran, it must be a default integer value.}
        \argRow{IN}{PE\_start}{The lowest virtual \ac{PE} number of the active set of \ac{PE}s. PE\_start must be of type integer. If you are using \Fortran, it must be a default integer value.}
        \argRow{IN}{logPE\_stride}{The log (base 2) of the stride between consecutive virtual \ac{PE} numbers in the active set. logPE\_stride must be of type integer. If you are using \Fortran, it must be a default integer value.}
        \argRow{IN}{PE\_size}{The number of \ac{PE}s in the active set. PE\_size must	be of type integer. If	 you are using \Fortran, it must be a default integer value.}
        \argRow{IN}{pWrk}{A symmetric work array. The pWrk argument must have the same data type as target. In \CorCpp,	this contains max(\VAR{nreduce}/2 + 1, \CONST{\_SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE}) elements. In \Fortran, this contains max(\VAR{nreduce}/2 + 1, \CONST{SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE}) elements.}
        \argRow{IN}{pSync}{A symmetric work array. In \CorCpp, \VAR{pSync} must be of type long and size \CONST{\_SHMEM\_REDUCE\_SYNC\_SIZE}. In \Fortran, \VAR{pSync} must be of type integer and size \CONST{SHMEM\_REDUCE\_SYNC\_SIZE}. If you are using \Fortran, it must be a default integer value. Every element of this array must be initialized with the value \CONST{\_SHMEM\_SYNC\_VALUE} (in \CorCpp) or \CONST{SHMEM\_SYNC\_VALUE} (in \Fortran) before any of the \ac{PE}s in the active set enter the reduction routine.}
 %API description
 {  
 \openshmem reduction	routines compute one or more
 reductions across symmetric arrays on multiple virtual \ac{PE}s. A
 reduction performs an associative binary operation across a set of
 values.	 
 
  The \VAR{nreduce} argument determines the number of separate reductions to
 perform.	 The source array on all \ac{PE}s in the active set	 provides one
 element	for each reduction. The results of the reductions are placed
 in the target array on all \ac{PE}s in the active set. The active set is
 defined by the PE\_start, logPE\_stride, PE\_size triplet.

 The source and target arrays may be the same array, but they may not be
 overlapping arrays.

 As with all SHMEM collective routines, each of these routines assumes
 that only \ac{PE}s in the active set call the routine. If a \ac{PE} not in the
 active set calls a SHMEM collective	 routine, undefined behavior
 results.

 The values of arguments \VAR{nreduce}, \VAR{PE\_start}, \VAR{logPE\_stride}, and \VAR{PE\_size}
 must be equal on all \ac{PE}s in the active set. The same target and source
 arrays, and the same pWrk and pSync work arrays, must be passed to all
 \ac{PE}s in the active set.

 Before any \ac{PE}	calls a reduction routine, you must ensure that the
 following conditions exist (synchronization via a barrier or some other
 method is often needed to ensure this): The pWrk and pSync arrays on
 all \ac{PE}s in the active set are not still in use from a prior call	 to a
 collective \openshmem routine. The target array on all \ac{PE}s in the active
 set is ready to accept the results of the reduction.

 Upon return from a reduction routine, the following are true for the
 local \ac{PE}: The target array is updated. The values in the \VAR{pSync} array
 are restored to the original values.
}
 \desTB { When calling from \Fortran, the target date types are as follows:}
        {
		  \cRow{Routine}{Data Type}
		  \cRow{shmem\_int8\_and\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_\_int4\_and\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_comp8\_max\_to\_all}{Complex, with an element size	equal to two 8-byte real values.}
		  \cRow{shmem\_int4\_max\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_int8\_max\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_real4\_max\_to\_all}{Real, with an element size of 4 bytes.]
		  \cRow{shmem\_real16\_max\_to\_all}{Real, with an element size of 16 bytes.}
		  \cRow{shmem\_int4\_min\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_int8\_min\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_real4\_min\_to\_all}{Real, with an element size of 4 bytes.}
		  \cRow{shmem\_real8\_min\_to\_all}{Real, with an element size of 8 bytes.}
		  \cRow{shmem\_real16\_min\_to\_all}{Real,with an element size of 16 bytes.}
		  \cRow{shmem\_comp4\_sum\_to\_all}{COMPLEX(KIND=4).}
		  \cRow{shmem\_comp8\_sum\_to\_all}{Complex. If you are using \Fortran, it must be a default complex value.}
		  \cRow{shmem\_int4\_sum\_to\_all}{INTEGER(KIND=4).}
		  \cRow{shmem\_int8\_sum\_to\_all}{Integer. If you are using \Fortran, it must be a default integer value.}
		  \cRow{shmem\_real4\_sum\_to\_all}{REAL(KIND=4).}
		  \cRow{shmem\_real8\_sum\_to\_all}{	 Real. If you are using \Fortran, it must be a default real value.}
		  \cRow{shmem\_real16\_sum\_to\_all}{	 Real. If you are using \Fortran, it must be a default real value.}
		  \cRow{shmem\_comp4\_prod\_to\_all	}{ Complex, with an element size	equal to two 4-byte real values. }		  \cRow{shmem\_comp8\_prod\_to\_all	}{ Complex, with an element size	equal to two 8-byte real values.}
		  \cRow{shmem\_int4\_prod\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_int8\_prod\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_real4\_prod\_to\_all}{Real, with an element size of 4 bytes.}
		  \cRow{shmem\_real8\_prod\_to\_all}{Real, with an element size of 8 bytes.}
		  \cRow{shmem\_real16\_prod\_to\_all}{Real, with an element size of 16 bytes.}
		  \cRow{shmem\_int8\_or\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_int4\_or\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_comp8\_xor\_to\_all}{Complex, with an element size equal to two 8-byte real values.}
		  \cRow{shmem\_comp4\_xor\_to\_all}{Complex, with an element size equal to two 4-byte real values.}
		  \cRow{shmem\_int8\_xor\_to\_all}{Integer, with an element size of 8 bytes.}
		  \cRow{shmem\_int4\_xor\_to\_all}{Integer, with an element size of 4 bytes.}
		  \cRow{shmem\_real8\_xor\_to\_all}{Real, with an element size of 8 bytes.}
		  \cRow{shmem\_real4\_xor\_to\_all}{Real, with an element size of 4 bytes.}
		  }
}%end of DesB
 %Return Values     
\desR{None.}

% Notes. If there are no notes, this field can be left empty.
\notesB{  
 All \openshmem reduction routines reset the values in pSync before they
 return, so a particular pSync buffer need only be initialized the first
 time it is used.

 You must ensure that the \VAR{pSync} array is not being updated on any \ac{PE} in
 the active set while any of the \ac{PE}s participate in processing of a
 SHMEM reduction routine. Be careful to avoid the following situations:
 If the pSync array is initialized at run	time, some type of synchronization is needed to
 ensure that all \ac{PE}s in the working set have initialized \VAR{pSync} before any of 
 them enter an \openshmem routine called
 with the \VAR{pSync} synchronization array. A \VAR{pSync} or \VAR{pWrk} array can be
 reused in a subsequent reduction routine call only if none of the \ac{PE}s
 in the active set are still processing a prior reduction routine call
 that used the same \VAR{pSync} or \VAR{pWrk} arrays. In general,	 this can be
 assured	only by doing some type of synchronization. However, in the
 special case of reduction routines being called with the same	active
 set, you can allocate two \VAR{pSync} and \VAR{pWrk} arrays and alternate between
 them on successive calls.
}

%Example
\exampleB{
%For each example, you can enter it as an item.
                  \exampleITEMF
                  { This \Fortran{} example statically initializes the \VAR{pSync} array and finds the logical AND of the integer variable FOO across all even \ac{PE}s.}
                  {./EXAMPLES/shmem_and_example.90}
                  {}
                   \exampleITEMF
	          {This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the maximum value of real variable FOO across all even \ac{PE}s.}
                  {./EXAMPLES/shmem_max_example.90}
                  {}
                  \exampleITEMF
                  { This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the minimum value of real variable FOO across all the even
 \ac{PE}s.}
                 {./EXAMPLES/shmem_min_example.90}
                 {}
                 \exampleITEMF
                  {This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the sum of the real variable FOO across all even \ac{PE}s.}
                  {./EXAMPLES/shmem_sum_example.90}
                  {}
                 \exampleITEMF
                  {This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the product of the real variable FOO across all the even \ac{PE}s.}
                  {./EXAMPLES/shmem_prod_example.90}
                  {}
                 \exampleITEMF
                  {This \Fortran{} example statically initializes the \VAR{pSync} array
 and finds the logical OR of the integer variable FOO across all even
 \ac{PE}s.}
                 {./EXAMPLES/shmem_or_example.90}
                 {}
                 \exampleITEMF
                  {This \Fortran{} example statically initializes the \VAR{pSync} array
 and computes the exclusive XOR of variable FOO across all even \ac{PE}s.}
                  {./EXAMPLES/shmem_xor_example.90}
                   {} 
                 }  	
\eAPI 



