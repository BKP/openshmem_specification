In many cases, \openshmem routines will guarantee the correct completion of operations without any need for programs to check for error states, diagnose system problems, or retry operations. For example, there are no error codes returned for remote memory operations. The implementation is expected to internally attempt any feasible checking and recovery to best guarantee completion as specified. However, there are also cases where routines return error codes to allow programs to detect problems that may be correctable at the application layer, e.g. requests for system resources that cannot be fulfilled at runtime.

\CorCpp routines that return an integer error code follow the convention that \CONST{0} indicates successful local completion of the operation. This is considered a best effort of the implementation to indicate that all required local operations have been performed correctly inside the routine and the internal \openshmem state on the calling \ac{PE} is consistent with the description of the routine and its arguments upon completion. Implementations may use an integer return value from a routine to define integer error codes specific to the implementation as long as those codes are not already explicitly defined for that routine.

Because \openshmem defines asynchronous communication operations, errors may arise at any time as communications proceed. In these cases, the implementation might generate error messages or abort the application when errors occur. The \openshmem specification cannot define these types of errors, and leaves it to the implementation to determine how these types of errors should be handled.

Collective operations involving many \acp{PE} may return values indicating success while other \acp{PE} are still executing the collective operation. By default, return values indicating success of a collective routine on one \ac{PE} do not indicate that all \acp{PE} involved in the collective operation will return from the routine successfully. If a collective routine provides any such global error checking behavior, it will be explicitly stated in the description of that routine.

\openshmem implementations for production environments may do minimal internal error checking for performance reasons. Also, some errors may be undetectable or uncorrectable due to limitations in underlying technologies, resulting in undefined behaviors. For these reasons, \openshmem generally considers that when routine parameters are invalid or violate requirements specified in this document, behavior is undefined. Likewise, when ordering or synchronization of communication operations violates requirements specified in this document, behavior is undefined.

Applications are encouraged but not required to attempt to continue execution in the face of resource allocations errors, such as lack of network resources or memory resources. In these cases, if resource allocation fails inside a routine with an integer return code, applications should return some nonzero value, which may have implementation specific definition. If the routine has some other out parameter, such as pointer to a new memory allocation, routines may specify that the out parameter has some sentinel value to indicate failure to complete the operation.

If some routine specified in this document does not explicity state resulting error behavior when a program violates the routine assumptions and requirements, then the behavior is undefined, and could include continuing execution regardless, aborting the application with an informative message, returning sentinel values in outgoing parameters, launching a debugger, tweeting the failure information as emoji, sounding a rather loud siren, or any other behavior which the implementation might find desirable.
