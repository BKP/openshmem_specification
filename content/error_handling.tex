In many cases, \openshmem routines will guarantee the correct completion of operations without any need for programs to check for error states, diagnose system problems, or retry operations. For example, there are no error codes returned for remote memory operations. The implementation is expected to internally attempt any feasible checking and recovery to best guarantee completion as specified. However, there are also cases where routines return error codes to allow programs to detect problems that may be correctable at the application layer, e.g. requests for system resources that cannot be fulfilled at runtime.

\CorCpp routines that return an integer error code follow the convention that \CONST{0} indicates successful local completion of the operation. This is considered a best effort of the implementation to indicate that all required local operations have been performed correctly inside the routine and the internal \openshmem state on the calling \ac{PE} is consistent with the description of the routine and its arguments upon completion. Implementations may use an integer return value from a routine to define integer error codes specific to the implementation as long as those codes are not already explicitly defined for that routine.

Because \openshmem defines asynchronous communication operations, errors may arise at any time as communications proceed. In these cases, the implementation might generate error messages or abort the application when errors occur. The \openshmem specification cannot define these types of errors, and leaves it to the implementation to determine how these types of errors should be handled.

Collective operations involving many \acp{PE} may return values indicating success while other \acp{PE} are still executing the collective operation. So, return values indicating success of a collective routine on one \ac{PE} do not by default indicate that all \acp{PE} involved in the collective operation will return from the routine successfully. If a collective routine provides any such global error checking behavior, it will be explicitly stated in the description of that routine.

\openshmem implementations for production environments may do minimal internal error checking for performance reasons. Also, some errors may be undetectable or uncorrectable due to limitations in underlying technologies, resulting in undefined behaviors. For these reasons, \openshmem does not provide strict error checking guarantees in most cases. For \CorCpp routines returning integer error codes, implementations are guided, but not required, to do the following:

\begin{itemize}
\item Return nonzero error codes and avoid application abort behaviors for resource allocation failure.
\item[] Examples of resource allocation failure are: context creation failure due to lack of network resources, team context creation failure due to lack of team resources, team creation failure due to lack of network or symmetric memory resources.
\item Return nonzero error codes when encountering errors that are likely transient and are not likely to result in the application or library becoming inconsistent.
\item Abort the application with an informative message if allowing it to continue would likely result in the application or library state becoming inconsistent.
\end{itemize}



