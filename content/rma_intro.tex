The \ac{RMA} routines described in this section are one-sided communication
mechanisms of the \openshmem{} \ac{API}. While using these mechanisms, the user
is required to provide parameters only on the calling side. A characteristic of
one-sided communication is that it decouples communication from the
synchronization. One-sided communication mechanisms transfer the data but do not
synchronize the sender of the data with the receiver of the data. 

\openshmem{} \ac{RMA} routines are all performed on the symmetric objects.  The
initiator \ac{PE} of the call is designated as \source{}, and the \ac{PE} in
which memory is accessed is designated as \dest{}. In the case of the remote
update routine, \PUT{}, the origin is the \source{} \ac{PE} and the destination
\ac{PE} is the \dest{} PE. In the case of the remote read routine, \GET{}, the
origin is the \dest{} \ac{PE} and the destination is the \source{} \ac{PE}.

Where appropriate compiler support is available, \openshmem{} provides type-generic 
one-sided communication interfaces via \Celev{} generic selection 
(\Celev{} \S6.5.1.1\footnote{Formally, the \Celev{} specification is ISO/IEC 9899:2011(E).})
for block, scalar, and block-strided put and get communication. 
Such type-generic routines are supported for the
\newtext{\Celev{}
``standard integer types'' (\Celev{} \S6.2.5.7),
``real floating types'' (\Celev{} \S6.2.5.10),
``exact-width integer types'' (\Celev{} \S7.20.1.1),
``integer types capable of holding object pointers'' (\Celev{} \S7.20.1.4),
and the integer types \textit{size\_t} and \textit{ptrdiff\_t} defined in
stddef.h (\Celev{} \S7.19), which are collectively called the}
``standard \ac{RMA} types''
\newtext{and are listed} \oldtext{identified} in Table \ref{stdrmatypes}.
\newtext{Implementations may optionally support additional types.}

\textbf{\newtext{Note to implementors:}}
\begin{itemize}
\item \newtext{%
  In order to provide compatibility between C and C++, implementors may elect
  to include a dependence on stdbool.h, which provides the macro \textit{bool}.
  Alternatively, implementors may elect to avoid this dependence and use the
  C99\footnote{Formally, the C99 specification is ISO/IEC 9899:1999(E), including amendments and corrections.}
  \textit{\_Bool} type explicitly.
  }
\end{itemize}

\begin{table}[h]
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      \TYPE              & \TYPENAME  \\ \hline
      float              & float      \\ \hline
      double             & double     \\ \hline
      long double        & longdouble \\ \hline
      char               & char       \\ \hline
%\newtext {
      signed char        & schar      \\ \hline
%}
      short              & short      \\ \hline
      int                & int        \\ \hline
      long               & long       \\ \hline
      long long          & longlong   \\ \hline
%\newtext {
      bool               & bool       \\ \hline
      unsigned char      & uchar      \\ \hline
      unsigned short     & ushort     \\ \hline
      unsigned int       & uint       \\ \hline
      unsigned long      & ulong      \\ \hline
      unsigned long long & ulonglong  \\ \hline
      int8\_t            & int8       \\ \hline
      int16\_t           & int16      \\ \hline
      int32\_t           & int32      \\ \hline
      int64\_t           & int64      \\ \hline
      uint8\_t           & uint8      \\ \hline
      uint16\_t          & uint16     \\ \hline
      uint32\_t          & uint32     \\ \hline
      uint64\_t          & uint64     \\ \hline
      intptr\_t          & intptr     \\ \hline
      uintptr\_t         & uintptr    \\ \hline
      size\_t            & size       \\ \hline
      ptrdiff\_t         & ptrdiff    \\ \hline
%}
    \end{tabular}
    \caption{Standard \ac{RMA} Types and Names}
    \label{stdrmatypes}
  \end{center} 
\end{table}
