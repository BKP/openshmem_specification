\section{Programming Model Overview}
%SP: Addressing suggestions from discussion on 01/28/2014 Merging the commented portions into the body. 
%The \openshmem programming model consists of library functions that provide
%low-latency, high-bandwidth communication  for  use  in  highly  parallelized 
%scalable programs. The functions in the \openshmem \ac{API} provide a programming 
%model for exchanging data between cooperating parallel processes. The resulting programs are similar 
%in style to \ac{MPI} programs. The \openshmem \ac{API} can be used either alone 
%or in combination with \ac{MPI} functions in the same parallel program.
\openshmem implements a \ac{PGAS} model. In the \ac{PGAS} model, each process has a local and 
globally shared memory where portions of the shared memory may have affinity to a particular process. 
\openshmem implements \ac{PGAS} by defining symmetric data objects as a mechanism to share information among \openshmem processes or \acp{PE}. 
The \openshmem library functions provide low-latency, high-bandwidth communication \ac{API} for  use in highly parallelized 
scalable programs. The \ac{API} allows communication and synchronization operations on both private (local) and remotely accessible data objects. 
\openshmem is a library and unlike UPC, CAF, Titanium, X10 and Chapel, which are all
PGAS languages, it relies on the programmer to use the library calls  to implement the correct semantics of its programming model.
The \openshmem data-transfer functions are one-sided in nature. This means that a local \ac{PE} executing a data-transfer does not require the participation of the remote \ac{PE} to complete the operation. This allows for overlap between communication and computation to hide data-transfer latencies. This makes  \openshmem ideal for unstructured, small/medium size data communication patterns.
%\rcomment{Manju: To do - Make sure the first paragraph does not say the same
%things has first paragraph of Section 1}

%An \openshmem program is currently \ac{SPMD} in style. The
%\openshmem  processes, called \ac{PE}s, all start at the
%same time, and they all run the same program. Usually the \ac{PE}s perform
%computation on their own subdomains of the larger problem, and periodically 
%communicate with other \ac{PE}s to exchange information on which the
%next computation phase depends.
%SP: Addressing suggestions from discussion on 01/31/2014

%Data latency is  the  period  of  time that starts when a \ac{PE} initiates a transfer of data 
%and ends when a \ac{PE} can use the data. %SP: What about put? Not guaranteed till synchronization is hit.

%SP: Addressing suggestions from discussion on 01/28/2014
%\openshmem functions support remote data transfer through \FUNC{put} operations, which  transfer data to a 
%different \ac{PE}, get operations, which transfer data from a different \ac{PE}, and remote pointers, which 
%allow direct  references  to  data objects owned by another \ac{PE}. Other operations supported are \FUNC{collective} 
%\FUNC{broadcast} and \FUNC{reduction}, \FUNC{barrier synchronization}, and \FUNC{atomic memory operations}. 
%An atomic memory operation  is an atomic read-and-update operation, such as a fetch-and-increment, on a remote
%or local data object.

%\rcomment{Manju: [The idea is to talk SPMD. We are talking about nature of interfaces rather than 
% the interfaces that enable SPMD. Replace the second paragraph with the one below ?]}
%\rcomment{\\ Oscar: I'm good with this change. minor change to say the SPMD can be used to decompose work\\}
The \openshmem{} interfaces can be used to implement \ac{SPMD} style programs. It provides interfaces 
to start the \openshmem{} \ac{PE}s in parallel, and communication and synchronization interfaces to access symmetric data objects across \ac{PE}s. These interfaces can be leveraged to divide a problem to into multiple sub-problems that can solved independently or with co-ordination using the communication and synchronization interfaces.
The \openshmem specification defines library calls, constants, variables, and language bindings for \Clang{} and \Fortran{}.
The \Cpp{} interface is currently the same as that for \Clang. An overview of the important \openshmem operations is described below:

\begin{enumerate}
\item \textbf{Data Transfers }

\begin{enumerate}
\item One-sided \FUNC{puts} : the local \ac{PE} specifies the source
data (local or symmetric) to be written to the symmetric object on the remote \ac{PE}. 
\item One-sided \FUNC{gets} : an explicit fetch operation is used to copy a symmetric object
from a remote \ac{PE} and store it to an object on the local \ac{PE}.\end{enumerate}

%\begin{description}
%\item [{{Note:}}] By avoiding the need for matching send and receive
%calls, \openshmem simplifies the communication process by reducing the
%number of calls required to have one \ac{PE} interact with other \ac{PE}s. 
%\end{description}
\item \textbf{Synchronization Mechanisms }
\begin{enumerate}
\item \FUNC{Fence}: Ensures ordering of PUT operations in respect to the target \ac{PE}. 
\item \FUNC{Quiet}: Ensures ordering of PUT operations to respect to all \acp{PE}. 
\item \FUNC{Barrier}: A collective synchronization routine in which no \ac{PE} may leave
the barrier prior to all \ac{PE}s entering the barrier. 
\end{enumerate}
\item \textbf{Collective Communication}

\begin{enumerate}
\item \FUNC{Broadcast}: Copy a symmetric object from one \ac{PE} to one or more remote
\acp{PE}. 
\item \FUNC{Collection}: Concatenate symmetric objects from the source array to a target
array over the specified \acp{PE}. 
\item \FUNC{Reduction}: Perform an associative binary operation over the specified
\ac{PE}s. 
\end{enumerate}
\item \textbf{Address Manipulation}

\begin{enumerate}
\item Allocating and deallocating symmetric objects in the symmetric space.
\end{enumerate}
\item \textbf{Locks}

\begin{enumerate}
\item Implementation of mutual exclusion.
\end{enumerate}
\item \textbf{Atomic Memory Operations}

\begin{enumerate}
\item Swap, Conditional Swap, Add and Increment 
\end{enumerate}
\item \textbf{Data Cache control}

\begin{enumerate}
\item Implementation of mechanisms to exploit the capabilities of hardware
cache if available.
\end{enumerate}
\end{enumerate}
%\begin{description}
%\item [{{Note:}}] More information about \openshmem routines can be found
%in the Library Routines section.
%\end{description}
