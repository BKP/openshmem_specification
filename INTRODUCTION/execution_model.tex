%Outline
%%Exectution model
%   *Define what is a OpenSHMEM program: a set of processes (either SPMD or MIMD?) where each process has its own 'local' (private) memory and symmetric memory regions that may be accessible by any PEs.
%   *Each OpenSHMEM process is called a processing element (PE)
%   *Each PE may be mapped to many to one hardware cores/threads or less.
%   *The number of PEs is specified at launch/runtime.
%   *Each PE must call startpe to initialize the OpenSHMEM runtime, before any other call for OpenSHMEM. There is an implicit barrier at startpe.
%   *Each PE executes asynchronously following Fortran or program execution in C [ISO/IEC00 Sec. 5.1.2.3]
%   *Each PE will have a unique global identifier and the execution of a program may depend on the PE id, if executed in SPMD.
%   *PE id may be used for library calls synchronizations, control flow constructs language  in C/Fortran
%   *PE may allocate symmetric data objects via a symmetric heap 
%   *As of now, PEs may finish execution at any time by returning from the main function. (no call to shmem_finalize yet!)
%   
%  %Memory model
%    *Each OpenSHMEM PEs may have symmetric memory that is accessible by other PEs. 
%    *Symmetric memory is a region of memory where all the an instance of a data objects is replicated across PEs, have 
%     the same the same layout and relative offset.
%    *All PEs can allocate a symmetric data objects using the symmetric heap, but they must do so as a collective operation. (is there a barrier after shmalloc?)
%    *All writes to symmetric memory are relaxed (I'm not sure if this is the completion semantics) and are guaranteed to be visible to other PEs after a barrier_all, barrier(?), quiet, (what about wait? does it means iti sonly visible to me?) 
%    *Calls to barrier, barrier_all, quiet, wait, lock, atomics, are meant to guarantee memory consistency across PEs.
%    *Read/Writes to symmetic data object may appear after startpe or after a the symmetric data object has been allocated in the symmetric heap (if it is a dynamic).
%    *Operations like reduction, collect, etc guarantee memory consistency after completion(?)
%    *Data races are possible in OpenSHMEM if multiple PEs write/read a symmetric data object from a single PE without proper synchronization.  

%This comes from the UPC spec:
%The memory consistency model in a language defines the order in which the results of write operations may be observed through read operations.
%The behavior of a OpenSHMEM program may depend on the timing of accesses to symetric variables on PEs, so in general a program defines a set of possible executions, 
%rather than a single execution. The memory consistency model constrains the set of possible executions for a given program; the user may then rely 
%on properties that are true of all of those executions.
    

\section{Execution Model}

This section describes the Execution Model of an \openshmem application.

\openshmem uses a Single Process Multiple Data (SPMD) approach to express
parallelism. An \openshmem application makes use of multiple processors,
referred to as Processing Elements or PEs, to complete operations
in parallel.

% OpenSHMEM applications may be launched using a dispatcher program,
% but it is not required. This dispatcher program may perform steps
% needed by the implementation to start the application on the desired
% processing elements. The following is an example of using a dispatcher:
% \lstinline[language=bash]!oshrun -np 4 myprogram!

\openshmem requires initialization before using any of the library
routines. To this end, the program issues a call to the \textbf{start\_pes()}
routine. \textbf{start\_pes()} performs any required initialization
steps, such as setting up the symmetric heap for every PE and creating
the PE numbers. The symmetric heap is one of the memory spaces
that is remotely accessible by all PEs. The symmetric heap is discussed
further in the Memory Model section. The PE numbers are the
identifiers used to refer to each of the PEs involved in the execution.
These PE numbers are integers assigned in a monotonically
increasing manner from zero to the total number of PEs minus 1.

Data transfer in \openshmem is possible through several one-sided put
(for write) and get (for read) operations, as well as various collective
routines such as broadcasts and reductions.

Query routines are available to gather information about the execution.
\openshmem also provides synchronization routines to coordinate data
transfers and other operations. 

It is up to the implementation how to handle the finalization of the
\openshmem library and any other resources initialized by the library:
there is currently no explicit call for the programmer.

\subsection{Communication Progress}

The \openshmem model assumes that computation and communication are
naturally overlapped.  \openshmem programs are expected to exhibit
progression of communication both with and without \openshmem calls.

Consider a PE that is engaged in a long computation with no \openshmem calls.
Other PEs must be able to communicate (put/get,
collective, atomic) with that computationally-bound PE without that PE
issuing any explicit \openshmem calls.

\openshmem communication calls involving that PE must progress
regardless of when that PE next engages in an \openshmem call.

\textbf{Note to implementers:} progress will often be ensured through
the use of a dedicated progress thread in software, or through
network hardware that offloads communication handling from processors.

\subsection{Atomicity Guarantees}

\openshmem contains a number of routines that operate on symmetric data
atomically.  These routines guarantee that accesses by \openshmem's
atomic operations will be exclusive, but do not guarantee exclusivity
in combination with other routines, either inside \openshmem's or
outside.

For example: during the execution of a remote integer increment
operation on a symmetric variable ``x'', no other \openshmem atomic
operation may access ``x''.  After the increment, ``x'' will have
increased its value by 1 on the target PE, at which point other
atomic operations may then modify that ``x''.
